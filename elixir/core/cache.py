import msgpack
from flask_caching import Cache

from elixir.core.config import cfg
from elixir.core.logger import log


class ExtendedCacheMsgPack(Cache):
    application = ""

    def get_key(self, namespace="", identifier="", user_uuid=None):
        """
        Generate a cache key, optionally user-specific.

        :param namespace: The primary namespace of the cache key. Optional.
        :param identifier: An optional identifier within the namespace.
        :param user_uuid: Optional user secondary ID for user-specific keys.
        :return: A string representing the cache key.
        """
        key_parts = [self.application]

        if user_uuid:
            key_parts.extend(["user", user_uuid])

        key_parts.extend([namespace, identifier])

        return ":".join(filter(None, key_parts))

    def serialize(self, data):
        """Serialize the data using MessagePack."""
        return msgpack.packb(data, use_bin_type=True)

    def deserialize(self, data):
        """Deserialize the data using MessagePack."""
        return msgpack.unpackb(data, raw=False)

    def get_data(self, cache_key):
        """Get data from the cache."""
        return self._get_cache_data(cache_key)

    def set_data(self, cache_key, data, cache_timeout=3600, *args):
        """Set data in the cache."""
        return self._set_cache_data(cache_key, data, cache_timeout, *args)

    def get_or_set(
        self,
        cache_key,
        data_func=None,
        cache_timeout=3600,
        *args,
    ):
        """
        Get data from the cache or generate it and set it in the cache.

        :param cache_key: The key for the cache entry.
        :param data_func: Optional function to generate data for setting or updating the cache.
        :param refresh: Boolean flag to force refresh the cache.
        :param cache_timeout: Cache timeout in seconds. Defaults to 3600 (1 hour).
        :param args: Arguments to pass to data_func, if provided.
        :return: Data from the cache or generated by data_func.
        """
        # # If refresh is True, invalidate the cache entry
        # if refresh:
        #     self.invalidate(cache_key)

        # Try to get data from the cache
        cached_data = self._get_cache_data(cache_key)
        if cached_data is not None:
            return cached_data

        # No data in the cache, try to generate it with data_func
        if data_func:
            return self._set_cache_data(cache_key, data_func, cache_timeout, *args)

        log.error(f"Cache miss for {cache_key} with no data function to generate data")
        return None

    def _get_cache_data(self, cache_key):
        """Private method to get data from the cache."""
        try:
            cached_data = self.get(cache_key)
            if cached_data is not None:
                log.info(f"Cache hit for {cache_key}")
                return self.deserialize(cached_data)

            log.info(f"Cache miss for {cache_key}")
            return None
        except Exception as e:
            log.error(f"Error in _get_cache_data: {e}")
            raise

    def _set_cache_data(self, cache_key, data, cache_timeout=3600, *args):
        """
        Private method to set data in the cache. Data can be provided directly or generated by a function.

        :param cache_key: The key for the cache entry.
        :param data: The data to be cached or a function to generate the data.
        :param cache_timeout: Cache timeout in seconds.
        :param args: Arguments to pass to the data function, if it is a function.
        """
        try:
            # Check if data is a function and call it to get the data
            if callable(data):
                data = data(*args)

            serialized_data = self.serialize(data)
            self.set(cache_key, serialized_data, timeout=cache_timeout)
            log.info(f"Data set in cache for {cache_key}")
            return data
        except Exception as e:
            log.error(f"Error in _set_cache_data: {e}")
            raise

    def invalidate(self, cache_key):
        """Invalidate a cache entry."""
        log.info(f"Invalidating {cache_key}")
        self.delete(cache_key)

cache = ExtendedCacheMsgPack()
cache.application = cfg.application
